#include <avr/power.h>
#include <Adafruit_NeoPixel.h>
#include <RTClib.h>

#define PIN_LED      3
#define PIN_BTN_UP   4
#define PIN_BTN_MODE 5
#define PIN_BTN_DOWN 6

enum class Mode {
  CLOCK,
  SETTING_HOUR,
  SETTING_MINUTE,
  SETTING_SECOND,
  LAST_CYCLE,
  CALIBRATION,
  ERROR_NO_RTC,
};

enum class Button {
  UP,
  MODE,
  DOWN,
  COUNT,
};

const uint8_t BUTTON_TO_PIN[] = {
  PIN_BTN_UP,
  PIN_BTN_MODE,
  PIN_BTN_DOWN,
};

class FracSec {
public:
  FracSec() 
      : ticks(0)
      , ticks_per_second(1)
      , last_second_lsb(false) {}
  
  void update(int second) {
    bool second_lsb = (second & 1) != 0;
    if (second_lsb != last_second_lsb) {
      last_second_lsb = second_lsb;
      ticks_per_second = ticks;
      ticks = 0;
    } else {
      ticks++;
    }
  }
  
  void frac() {  
    uint16_t frac = (uint16_t(ticks) * 256) / ticks_per_second;
    if (frac > 255) {
      frac = 255;
    }
    return frac;
  }
  
private:
  uint16_t ticks;
  uint16_t ticks_per_second;
  bool last_second_lsb;
};

Adafruit_NeoPixel neo;
RTC_DS3231 rtc;
Mode mode = Mode::CLOCK;
uint8_t button_counts[(int)(Button::COUNT)];
FracSec fracsec;

void setup() {
  pinMode(PIN_BTN_UP,   INPUT_PULLUP);
  pinMode(PIN_BTN_MODE, INPUT_PULLUP);
  pinMode(PIN_BTN_DOWN, INPUT_PULLUP);
  
  neo = Adafruit_NeoPixel(84, PIN_LED, NEO_GRBW); 
  neo.begin();

  if (rtc.begin()) {
    if (rtc.lostPower()) {
      rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
    }
    mode = Mode::CLOCK;
  } else {
    mode = Mode::ERROR_NO_RTC;
  }
}

void setInner(uint8_t* pixels, uint32_t i, uint8_t r, uint8_t g, uint8_t b, uint8_t w) {
  pixels[(60+i)*4+1] = r;
  pixels[(60+i)*4+0] = g;
  pixels[(60+i)*4+2] = b;
  pixels[(60+i)*4+3] = w;
}

void setOuter(uint8_t* pixels, uint32_t i, uint8_t r, uint8_t g, uint8_t b, uint8_t w) {
  pixels[i*4+1] = r;
  pixels[i*4+0] = g;
  pixels[i*4+2] = b;
  pixels[i*4+3] = w;
}

void addInner(uint8_t* pixels, uint32_t i, uint8_t r, uint8_t g, uint8_t b, uint8_t w) {
  pixels[(60+i)*4+1] += r;
  pixels[(60+i)*4+0] += g;
  pixels[(60+i)*4+2] += b;
  pixels[(60+i)*4+3] += w;
}

void addOuter(uint8_t* pixels, uint32_t i, uint8_t r, uint8_t g, uint8_t b, uint8_t w) {
  pixels[i*4+1] += r;
  pixels[i*4+0] += g;
  pixels[i*4+2] += b;
  pixels[i*4+3] += w;
}

uint8_t falloff[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
  0x01, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 
  0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 
  0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x06, 0x06, 
  0x06, 0x07, 0x07, 0x07, 0x08, 0x08, 0x09, 0x09, 
  0x0a, 0x0a, 0x0b, 0x0b, 0x0c, 0x0d, 0x0d, 0x0e, 
  0x0f, 0x10, 0x11, 0x11, 0x12, 0x13, 0x14, 0x15, 
  0x16, 0x18, 0x19, 0x1a, 0x1b, 0x1d, 0x1e, 0x20, 
  0x21, 0x23, 0x25, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 
  0x30, 0x33, 0x35, 0x38, 0x3a, 0x3d, 0x40, 0x43, 
  0x46, 0x49, 0x4c, 0x50, 0x53, 0x57, 0x5b, 0x5f, 
  0x63, 0x67, 0x6c, 0x71, 0x76, 0x7b, 0x80, 0x85, 
  0x8b, 0x91, 0x97, 0x9d, 0xa4, 0xab, 0xb2, 0xb9, 
  0xc1, 0xc9, 0xd1, 0xda, 0xe3, 0xec, 0xf5, 0xff, 
};

uint8_t gamma[] = {
  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
  0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x02, 
  0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 
  0x03, 0x03, 0x04, 0x04, 0x04, 0x04, 0x04, 0x05, 
  0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x07, 
  0x07, 0x07, 0x08, 0x08, 0x08, 0x09, 0x09, 0x09, 
  0x0a, 0x0a, 0x0a, 0x0b, 0x0b, 0x0b, 0x0c, 0x0c, 
  0x0d, 0x0d, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f, 0x10, 
  0x10, 0x11, 0x11, 0x12, 0x12, 0x13, 0x13, 0x14, 
  0x14, 0x15, 0x16, 0x16, 0x17, 0x17, 0x18, 0x18, 
  0x19, 0x1a, 0x1a, 0x1b, 0x1c, 0x1c, 0x1d, 0x1e, 
  0x1e, 0x1f, 0x20, 0x20, 0x21, 0x22, 0x22, 0x23, 
  0x24, 0x25, 0x25, 0x26, 0x27, 0x28, 0x29, 0x29, 
  0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2e, 0x2f, 0x30, 
  0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 
  0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 
  0x40, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 
  0x49, 0x4a, 0x4b, 0x4c, 0x4e, 0x4f, 0x50, 0x51, 
  0x52, 0x53, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5b, 
  0x5c, 0x5d, 0x5e, 0x60, 0x61, 0x62, 0x64, 0x65, 
  0x66, 0x68, 0x69, 0x6a, 0x6c, 0x6d, 0x6e, 0x70, 
  0x71, 0x73, 0x74, 0x76, 0x77, 0x78, 0x7a, 0x7b, 
  0x7d, 0x7e, 0x80, 0x81, 0x83, 0x84, 0x86, 0x88, 
  0x89, 0x8b, 0x8c, 0x8e, 0x8f, 0x91, 0x93, 0x94, 
  0x96, 0x98, 0x99, 0x9b, 0x9d, 0x9e, 0xa0, 0xa2, 
  0xa3, 0xa5, 0xa7, 0xa9, 0xaa, 0xac, 0xae, 0xb0, 
  0xb1, 0xb3, 0xb5, 0xb7, 0xb9, 0xbb, 0xbc, 0xbe, 
  0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 
  0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde, 
  0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 
  0xf0, 0xf2, 0xf5, 0xf7, 0xf9, 0xfb, 0xfd, 0xff, 
};

uint8_t sinlut[] = {
  0x80,0x83,0x86,0x89,0x8c,0x8f,0x92,0x95,
  0x98,0x9c,0x9f,0xa2,0xa5,0xa8,0xab,0xae,
  0xb0,0xb3,0xb6,0xb9,0xbc,0xbf,0xc1,0xc4,
  0xc7,0xc9,0xcc,0xce,0xd1,0xd3,0xd5,0xd8,
  0xda,0xdc,0xde,0xe0,0xe2,0xe4,0xe6,0xe8,
  0xea,0xeb,0xed,0xef,0xf0,0xf2,0xf3,0xf4,
  0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfb,0xfc,
  0xfd,0xfd,0xfe,0xfe,0xfe,0xff,0xff,0xff,
  0xff,0xff,0xff,0xff,0xfe,0xfe,0xfd,0xfd,
  0xfc,0xfc,0xfb,0xfa,0xf9,0xf8,0xf7,0xf6,
  0xf5,0xf4,0xf2,0xf1,0xef,0xee,0xec,0xeb,
  0xe9,0xe7,0xe5,0xe3,0xe1,0xdf,0xdd,0xdb,
  0xd9,0xd7,0xd4,0xd2,0xcf,0xcd,0xca,0xc8,
  0xc5,0xc3,0xc0,0xbd,0xba,0xb8,0xb5,0xb2,
  0xaf,0xac,0xa9,0xa6,0xa3,0xa0,0x9d,0x9a,
  0x97,0x94,0x91,0x8e,0x8a,0x87,0x84,0x81,
  0x7e,0x7b,0x78,0x75,0x71,0x6e,0x6b,0x68,
  0x65,0x62,0x5f,0x5c,0x59,0x56,0x53,0x50,
  0x4d,0x4a,0x47,0x45,0x42,0x3f,0x3c,0x3a,
  0x37,0x35,0x32,0x30,0x2d,0x2b,0x28,0x26,
  0x24,0x22,0x20,0x1e,0x1c,0x1a,0x18,0x16,
  0x14,0x13,0x11,0x10,0xe,0xd,0xb,0xa,
  0x9,0x8,0x7,0x6,0x5,0x4,0x3,0x3,
  0x2,0x2,0x1,0x1,0x0,0x0,0x0,0x0,
  0x0,0x0,0x0,0x1,0x1,0x1,0x2,0x2,
  0x3,0x4,0x4,0x5,0x6,0x7,0x8,0x9,
  0xb,0xc,0xd,0xf,0x10,0x12,0x14,0x15,
  0x17,0x19,0x1b,0x1d,0x1f,0x21,0x23,0x25,
  0x27,0x2a,0x2c,0x2e,0x31,0x33,0x36,0x38,
  0x3b,0x3e,0x40,0x43,0x46,0x49,0x4c,0x4f,
  0x51,0x54,0x57,0x5a,0x5d,0x60,0x63,0x67,
  0x6a,0x6d,0x70,0x73,0x76,0x79,0x7c,0x80,
};

uint8_t button_down(Button button) {
  uint8_t pin = BUTTON_TO_PIN[(int)(button)];
  return digitalRead(pin) == LOW;
}

uint8_t button_press(Button button) {
  uint8_t& count = button_counts[(int)(button)];
  if (!button_down(button)) {
    count = 0;
    return false;
  } else {
    count += 4;
    return count == 4;
  }
}

void loop() {
  neo.clear();

  uint8_t* pixels = neo.getPixels();
  
  if (button_press(Button::MODE)) {
    mode = (Mode)((int)mode + 1);
    if (mode >= Mode::LAST_CYCLE) {
      mode = Mode::CLOCK;
    }
  }

  DateTime now;

  if (mode == Mode::ERROR_NO_RTC) {
      for (int i = 0; i < 24; i+=2) {
        setInner(pixels, i, 50, 0, 0, 0);
      }
  } else {
    now = rtc.now();
    fracsec.update(now.second());
  }

  switch (mode) {
    case Mode::CLOCK:
      if (button_down(Button::UP) && button_down(Button::DOWN)) {
        mode = Mode::CALIBRATION;
        break;
      }

      clock_tick(pixels, now);
      break;

    case Mode::SETTING_HOUR: {
      now = now - TimeSpan(0, 0, 0, now.second());
      if (button_press(Button::UP)) {
        now = now + TimeSpan(0, 1, 0, 0);
        rtc.adjust(now);
      } else if (button_press(Button::DOWN)) {
        now = now - TimeSpan(0, 1, 0, 0);
        rtc.adjust(now);
      }
      static uint8_t tick = 0;
      tick += 2;
      uint8_t pulse = sinlut[tick];
      
      draw_blips(pixels);
      addInner(pixels, (now.hour() * 2) % 24, 0, pulse, pulse, 100);
      addOuter(pixels, now.minute(), 100, 50, 50, 50);
      break;
    }
      
    case Mode::SETTING_MINUTE: {
      now = now - TimeSpan(0, 0, 0, now.second());
      if (button_press(Button::UP)) {
        now = now + TimeSpan(0, 0, 1, 0);
        rtc.adjust(now);
      } else if (button_press(Button::DOWN)) {
        now = now - TimeSpan(0, 0, 1, 0);
        rtc.adjust(now);
      }
      static uint8_t tick = 0;
      tick += 2;
      uint8_t pulse = sinlut[tick];

      draw_blips(pixels);
      addInner(pixels, (now.hour() * 2) % 24, 100, 50, 50, 50);
      addOuter(pixels, now.minute(), 0, pulse, pulse, 100);
      break;
    }
    
    case Mode::SETTING_SECOND: {
      if (button_press(Button::UP)) {
        now = now + TimeSpan(0, 0, 0, 5 - (now.second() % 5));
        rtc.adjust(now);
      } else if (button_press(Button::DOWN)) {
        now = now - TimeSpan(0, 0, 0, ((now.second() % 5) == 0) ? 5 : (now.second() % 5));
        rtc.adjust(now);
      }
      static uint8_t tick = 0;
      tick += 2;
      uint8_t pulse = sinlut[tick];

      draw_blips(pixels);
      addInner(pixels, (now.hour() * 2) % 24, 100, 50, 50, 50);
      addOuter(pixels, now.minute(), 100, 50, 50, 50);
      addOuter(pixels, now.second(), 0, pulse, pulse, 50);
      break;
    }
    
    case Mode::CALIBRATION:      
      setInner(pixels, 0,   
            digitalRead(PIN_BTN_UP)   * 100,  
            digitalRead(PIN_BTN_MODE) * 100,
            digitalRead(PIN_BTN_DOWN) * 100, 50);
      setInner(pixels, 6,   0,  0,  0, 50);
      setInner(pixels, 12,  0,  0,  0, 50);
      setInner(pixels, 18,  0,  0,  0, 50);
      setOuter(pixels, 0,   0,  0,  0, 50);
      setOuter(pixels, 15,  0,  0,  0, 50);
      setOuter(pixels, 30,  0,  0,  0, 50);
      setOuter(pixels, 45,  0,  0,  0, 50);

      for (int i =  1; i <  6; i++) { setInner(pixels, i, 50,  0,  0,  0); }
      for (int i =  7; i < 12; i++) { setInner(pixels, i,  0, 50,  0,  0); }
      for (int i = 13; i < 18; i++) { setInner(pixels, i,  0,  0, 50,  0); }
      for (int i = 19; i < 24; i++) { setInner(pixels, i, 30,  0, 30,  0); }

      for (int i =  1; i < 15; i++) { setOuter(pixels, i, 50,  0,  0,  0); }
      for (int i = 16; i < 30; i++) { setOuter(pixels, i,  0, 50,  0,  0); }
      for (int i = 31; i < 45; i++) { setOuter(pixels, i,  0,  0, 50,  0); }
      for (int i = 46; i < 60; i++) { setOuter(pixels, i, 30,  0, 30,  0); }
      break;
  }

  // Gamma correct
  for (int i = 0; i < 84*4; i++) {
    pixels[i] = gamma[pixels[i]];
  }
  
  neo.show();
}

uint16_t second_frac(uint32_t second) {
  static bool last_second_lsb;
  static uint16_t ticks = 0;
  static uint16_t ticks_per_second = 1;
  bool second_lsb = (second & 1) != 0;
  if (second_lsb != last_second_lsb) {
    last_second_lsb = second_lsb;
    ticks_per_second = ticks;
    ticks = 0;
  } else {
    ticks++;
  }
  uint16_t frac = (uint16_t(ticks) * 256) / ticks_per_second;
  if (frac > 255) {
    frac = 255;
  }
  return frac;
}

uint16_t distance(uint16_t now_16, uint8_t led, uint8_t count) {
  uint16_t out = now_16 - (led<<8);
  if (out > (count<<8)) { out += (count<<8); }
  return out;
}

void draw_blips(uint8_t* pixels) {
  for (uint8_t i = 0; i < 60; i++) {
    uint8_t w = 0;
    if (i % 5  == 0) { w =  50; }
    if (i % 15 == 0) { w = 100; }
    setOuter(pixels, i, 0, 0, 0, w);
  }
}

void clock_tick(uint8_t* pixels, DateTime now) {
  uint8_t minute = now.minute();
  uint8_t hour   = (now.hour() * 2 + (minute / 30)) % 24;
  uint8_t second_a = now.second();
  uint8_t second_b = (second_a+1) % 60;
  uint16_t frac  = second_frac(second_a);
  
  uint16_t second_16 = (uint16_t(second_a) << 8) + frac;
  uint16_t minute_16 = (uint16_t(minute) << 8) + (second_16 / 60);
  uint16_t hour_16 = (uint16_t(hour) << 8) + (minute_16 / 60);

  uint8_t a0 = second_a&0xff;
  uint8_t a1 = (second_a+85)&0xff;
  uint8_t a2 = (second_a+170)&0xff;

  for (uint8_t i = 0; i < 60; i++) {
    uint8_t r = 0, g = 0, b = 0, w = 0;
    
    uint16_t dist = distance(minute_16, i, 60);
    uint8_t phase = (minute_16 + (i<<8)) / 60;
    uint8_t trail = falloff[((60<<8) - dist) / 60];

    if (i % 5  == 0) { w =  50; phase += 50; }
    if (i % 15 == 0) { w = 100; phase += 50; }
    if (i == second_a) {
      w += (255-frac) >> 1;
    }
    if (i == second_b) {
      w += frac >> 1;
    }

    r = (sinlut[(phase    ) & 0xff] * uint16_t(trail)) >> 8;
    g = (sinlut[(phase+85 ) & 0xff] * uint16_t(trail)) >> 8;
    b = (sinlut[(phase+170) & 0xff] * uint16_t(trail)) >> 8;

    setOuter(pixels, i, r, g, b, w);
  }
 
  for (int i = 0; i < 24; i++) {
    uint8_t r = 0, g = 0, b = 0, w = 0;
        
    uint16_t dist = distance(hour_16, i, 24);
    uint8_t phase = (hour_16 + (i<<8)) / 24;
    uint8_t trail = falloff[((24<<8) - dist) / 24];
    r = (sinlut[(phase    ) & 0xff] * uint16_t(trail)) >> 8;
    g = (sinlut[(phase+85 ) & 0xff] * uint16_t(trail)) >> 8;
    b = (sinlut[(phase+170) & 0xff] * uint16_t(trail)) >> 8;
    
    setInner(pixels, i, r, g, b, w);
  }
}

